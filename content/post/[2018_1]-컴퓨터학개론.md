---
title: "[2018_1] 컴퓨터학개론"
date: 2019-06-30T20:48:32+09:00
draft: false
---

첫 학기에 들었던 컴퓨터학개론이다. 강의필기 + 중간/기말 대비용 요약본 정도 된다.

원래 에버노트에 정리해서 시험 때 인쇄해서 달달 읽었던 건데, 오랜만에 보니 딱히 새롭지는 않고 지겹기만 하다. 한번 쭉 읽으면서 마크다운 문법만 적용시켰다.

모르는 게 나오면 바로 찾아가면서 내 것으로 만드느라 덕지덕지이다. 정리도 개판이라 보기가 좀 힘들다. 마크다운으로 다 옮기기는 했는데, 블로그 css랑 잘 안 맞아서 리스트랑 이런 게 좀 안 예쁘게 나오는 듯. 모든 인용의 출처는 맨 아래에 명시해두었다.  

과목 자체에 대한 평은 쓸 게 별로 없지만, 전산학의 모든 분야를 폭넓게 배운다는 느낌이 좋았다. 배울 당시에도 나중에 엄청 도움될 거라고 생각했었고, 지금도 잘 써먹고 있다.

처음으로 깊게 공부했던 이론 과목이였던만큼 내 공부법에 어떤 문제가 있는지도 알 수 있는 과목이기도 했다. 호기심은 물론 좋지만, 모르는 것, 애매한 것에 너무 매달리는 것도 좋은 공부법은 아니다. 막히는 부분이 있으면 일단은 "뭐 그런가 보다" 하고 넘어가다 보면 뒷내용이 부연설명을 해줄 때도 많고, 모든 실마리가 풀리면서 이해도가 급상승하는 때도 있다. 물론 벼락치기에는 적용되지 않는 이야기이다. 그래서 복습을 철저히 하고, 시간을 두고 공부해야 한다는 것일까? 모르겠다.  

--------

## 1장

과학과 공학의 차이? 당연히 사람마다 견해가 다르다.  

* **Computer Science** : Input, Output으로부터 Process를 유추해서 설명하는 것. Process는 만들어 낸 것이 아닌 이미 있는 것.  
* 만유인력은 임의로 만들어 낸 것이 아니다. 가만히 있었는데 사과가 떨어졌다는 IO로부터 만유인력이라는 P를 유추.  
* **Computer Engineering** : 우리가 생각하는 Input, Output이 나오도록, Science의 결과를 이용하여, 필요에 맞게 Process를 설계, 구현, 보완  

Computer가 무엇인지 정의해 봐라 => 사람마다 견해가 다르다.  
P. 4 / Computer Science의 정의 : “어떤 문제를 해결하기 위해 알고리즘을 설계하고 개발하는 일련의 과정” => 완벽한 정의는 아닐 수도 있다는 이야기.  

(공학도로써 지켜야 할, 추구해야 하는 목적 2가지 : 문제해결능력, 소통(커뮤니케이션))  

**Definition of Algorithm** : 특정한 작업을 수행하는 명령어들의 유한집합=A finite set of instructions that, if followed, accomplishes a particular task.  
알고리즘이 만족시켜야 할 기준, 규범=criteria 5가지  

1. Input : 0개 이상 (Input이 없는 알고리즘의 예: 원주율의 n번째 자리는?)
2. Output : 1개 이상
3. Definiteness : 각 명령=instruction은 명확하고, 모호하지 않아야 한다. 누가 들어도 똑같이 알아먹어야 한다.
4. Finiteness : 알고리즘은 유한한 단계 후에, 모든 경우에 대해 어떻게든 끝나야 한다.
5. Effectiveness : (수행 가능성?) 모든 명령어들은 원칙적으로 종이와 연필만으로 수행될 수 있을 정도로, 현실적으로 실행이 가능해야 함. 각 명령은 (3)처럼 분명해야 하지만, 실행도 가능해야 한다.

*(5) Effectiveness는 알고리즘의 효율성이 아니다. 알고리즘의 효율성은 시간 복잡도 개념으로 들어간다.*  
*충분한 시간과 종이, 연필만 있으면 정확히 계산할 수 있어야 한다.*

운영체제는 알고리즘이라 할 수 없다. 4. Finiteness 충족X  
*참고 : 구글검색 is an operating system an algorithm*

Algorithm의 궁극적 목적 : **Optimial solution=최적해를 구하는 것.** but 시간이 오래 걸림.  
일부를 포기하고 sub-optimal solution=준최적해를 취해야 할 때도 있다.  
Algorithmic solution 이외에도 **Heuristic problem solving도 고려할 필요가 있다.**  
*컴퓨터 공학에서 발견법은 해결법이 정확히 해결되는지에 대한 문제를 무시하고 일반적으로 좋은 해결법이나 보다 간단한 해결법으로 풀고자 하는 문제 해결법이다. 예를 들어 상업적인 컴퓨터 바이러스 검색 소프트웨어들은 발견법으로 특정 속성이나 특징들을 찾아 바이러스나 나쁜 소프트웨어를 찾아낸다. 하지만 잠재적인 정확도 하락의 요인이 되기도 한다.*

speed=속도, cost=비용(시간 등) => 이 2개로 각종 시스템의 장단점 비교 가능. 2개 단어 알아둘 것. 비교할 때 2개만 알아두면 됨.

폰 노이만 : **stored-program computer (내장 프로그램 컴퓨터)**이라는 새로운 개념의 컴퓨터 시스템을 만듦. 명령어를 메모리에 넣어두고 필요할 때 꺼내 수행하는 방식. 지금까지도 이 뼈대를 벗어나지 못하고 있음.

* p.10 / 폰 노이만이 제안한 컴퓨터는 동작을 제어하는 인스트럭션을 이진 값으로 코드화하여, 데이터와 함께 메모리 안에 저장하도록 하는 시스템이다. 즉, 새로운 문제를 풀기 위해 이전과는 달리 기계 작동을 처음부터 새로 세팅하지 않는다. 다만, 인스트럭션의 순서만 다시 배열하도록 한다. 다시 말해서 프로그램을 만드는 것이다.
* 프로그램에서 사용하는 데이터와 프로그램 그 자체가 똑같은 형태로 메모리 저장공간을 점유하다 보니 데이터를 처리할 때와 같은 방법으로 새로운 프로그램을 만들 수 있고, 기존 프로그램을 변경할 수도 있다는 거죠. 쉽게 말해서 기존 물리적인 방법과 다르게 (초기에는 천공 테이프, 진공관 등 물리적인 방법으로 프로그램을 작성했음) 프로그램을 이용한 프로그래밍이 가능하게 되었고, 하드웨어 구현에 대한 전문지식이 없어도 원하는 프로그램을 작성할 수 있다는 거죠.
* 이 구조의 특장점을 꼽자면, 컴퓨터에 다른 작업을 시키려고 할 때 굳이 하드웨어(전선)를 재배치할 필요 없이 소프트웨어(프로그램)만 교체하면 되기 때문에 범용성이 크게 향상된다는 것이다. 전선을 일일이 교체할 경우 교체인원도 많이 필요하고 시간도 많이 잡아먹는 등 여러모로 불편함이 있지만(그 이전의 컴퓨터들은 스위치를 설치하고 전선을 연결하여 데이터를 전송하고 신호를 처리하는 식으로 프로그래밍하였다), 폰 노이만 구조를 도입하면 프로그램을 교체하는 것으로 모든 일이 끝난다. 이 엄청난 편의성 때문에, 현재 거의 모든 컴퓨터들은 폰 노이만 구조를 따르고 있다.

--------

## 2장

알고리즘을 표현할 수 있는 방법은 많다. (자연어, 순서도, 프로그래밍 언어, pseudo code, ...)  
알고리즘에서의 여러 요소 : 순차 동작, 조건 동작, 반복 동작  

**알고리즘의 우열? 시간 복잡도=Time Complexity**  
**문제의 크기가 n일 때, 이 문제를 푸는 데에 걸리는 시간**  

**수행 시간 : O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n)**  
**(상수 시간=constant < 로그 시간 < 선형 시간=linear < 선형 로그 시간 < 2차 시간=cubic < 지수 시간=exponential)**  

**Big-O Notation : O(n) (Order of n) => gives upper bound**  
*알고리즘의 시간복잡도는 주로 빅-오 표기법을 사용하여 나타내며,* ***이 빅-오 표기법은 계수와 낮은 차수의 항을 제외시키는 방법이다.*** *이런 방식으로 표현할 때, (예를 들면, 입력 크기를 무한대로 입력하여) 시간복잡도를 점근적으로 묘사한다고 말한다.*  
*예시로서, 만약 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 (어떤 n_0보다 크지 않은 모든 n에 대하여) 5n^3 + 3n의 식을 가진다면, 이 알고리즘의 점근적 시간 복잡도는 O(n^3)이라고 할 수 있다.*

**Omega Notation : Ω(n) (Order of at least n) => gives lower bound**  
*때로는 알고리즘이 상한선 없이 최소한 어느 정도 걸린다고 해야 할 때도 있을 것입니다. 그럴 때는 big-Ω 표기법을 사용합니다. 여기서 Ω는 그리스 문자 "오메가"입니다.*  

**Theta Notation : Θ(n) => gives both lower and upper bound**  
*중요한 것은 선형 검색의 최악의 경우의 실행 시간은 배열 크기인 n에 따라 커진다는 것입니다. 여기서 실행시간을 표시하기 위해 사용하는 표기법은 Θ(n)입니다.*  

**Best-case, Worst-case, Average-case**  
예) 순차 검색 : Best-case = O(1), Worst-case = O(n), Average-case = O(n/2)  
**어떤 알고리즘의 시간복잡도를 묻는 것은, Worst-case의 경우를 묻는 것이다.**  
*그렇다면 알고리즘마다 세가지의 경우를 모두 고려해야 할까? 그렇지 않다. 일단 Best-case는 고려해야 할 대상이 아니다. 어떤 알고리즘이던 Best-case는 1이기 때문이며 비현실적인 경우이기 때문이다. 그리고 Average-case는 고려하기에 애매하다. 위의 경우는 원하는 대상이 탐색 대상에 있을 확률을 50%라고 정했지만 세상의 모든 자료들이 50%확률로 탐색대상에 있을 것이라 단정지을 수 없다. 그리고 탐색대상에 있다 하더라도 n/2라는 수치는 근사치이기 때문에 '이 알고리즘의 시간복잡도는 n/2'라 표현하기가 뭐하다.* ***따라서 시간복잡도를 표현할 때는 Worst-case만을 이야기한다.***  

### Search

* 순차 검색=Sequential search : 첫 레코드부터 내가 원하는 자료가 나올 때까지 순서대로 탐색 => O(n)
* **이진 검색=Binary search** : (In ascending-sorted list) 중앙값이 원하는 값보다 큰가? 반씩 쪼개기의 힘. => O(log n)

*이진 검색 알고리즘(binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최고값이 되며, 작으면 그 값은 새로운 최하값이 된다. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다.*  
참고 : O(log n) (로그 시간)  
*이런 타입의 가장 쉬운 예제 알고리즘은, 문자열을 절반으로 쪼개어 그 오른쪽의 문자열을 다시 또 절반으로 쪼개고, 이를 반복하는 알고리즘으로 생각할 수 있다. 이 알고리즘은 우리가 각각의 출력 이전에 문자열을 절반으로 나누기 때문에, O(log n)시간 (n은 문자열의 길이) 이 소요된다. 이것은 출력 횟수를 증가시키기 위해서는 문자열의 길이를 두배로 늘려야 함을 의미한다.*  

### Sort

**(by compare & interchange)**

* Merge sort => O(n log n)
* (Heap sort)
* Selection sort => O(n^2) (최악의 경우의 비교 횟수를 생각해 보면, n(n-1)/2라는 걸 알 수 있다.)

**NOT by compare & interchange**

* Address calculation sort : 각 값을 메모리 주소에 할당 후 나중에 주소값 순서대로 읽음. 데이터 간 비교 없음. => O(n)

--------

## Chapter 10. 자료의 표현

bit : 컴퓨터에서 숫자를 나타내는 최소 단위  
byte : 8 * bit  

**문자의 표현**  
ASCII (7bit 이용, 나머지 1bit는 parity bit로 활용)  

*패리티 비트(Parity bit)는 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트이다. 전송하고자 하는 데이터의 각 문자에 1 비트를 더하여 전송하는 방법으로 2가지 종류의 패리티 비트(홀수, 짝수)가 있다. 패리티 비트는 오류 검출 부호에서 가장 간단한 형태로 쓰인다.*  
* *짝수(even) 패리티는 전체 비트에서 1의 개수가 짝수가 되도록 패리티 비트를 정하는 것인데, 이를테면 데이터 비트에서 1의 개수가 홀수이면 패리티 비트를 1로 정한다.*
* *홀수(odd) 패리티는 전체 비트에서 1의 개수가 홀수가 되도록 패리티 비트를 정하는 방법이다.*

오류 검출하는 완벽한 방법은 아니다. 예를 들어, 0000001 -> 0000111처럼 홀, 짝은 유지되지만 오류가 날 수 있다.  

그 외에 EBCDIC, 유니코드 등이 있다.  

Digital / Analog  

Hexadecimal=16진법, Decimal=10진법, Octal=8진법, Binary=2진법  

**10진수 (소수점 포함) -> 2진수 변환**  
정수 부분 : 평소대로 2로 계속 나눠서 나머지만 역순으로 쓴다.  
**소수 부분 : 소수부분 * 2 해서 1보다 작으면 0으로 두고, 1보다 크면 1로 두고 그 수에서 1을 뺀다. 이를 반복한다.**  
ex) 0.458 * 2 = 0.916 => 0  
    0.916 * 2 = 1.832 => 1  
    0.832 * 2 = 1.664 => 1  
    0.664 * 2 = 1.328 => 1  
    0.328 * 2 = 0.656 => 0  
    ...  
ex) 25.458(10) -> 11001.01110… (2)  
    7.25(10) -> 111.01000… (2)  

2진수 -> 8진수, 2진수 -> 16진수는 쉽다.  

* bin -> oct : 2진수 3비트씩 끊어서 생각.
* bin -> hex : 2진수 4비트씩 끊어서 생각.

p.278 10.2 이진수의 표현에 있는거 한번 읽어보기. 진법 간의 변환이 다 나와 있다.

**컴퓨터에서의 정수 표현** => 3가지 방법  

* Signed magnitude : 맨 앞 비트 하나를 부호 표현에 할당(플마). n비트로 -(2n-1 - 1) 부터 2n-1 - 1 까지의 정수 표현 가능.
* 1’s complement=1의 보수 : Signed magnitude랑 양수 부분은 똑같다. 음수 부분은 각각의 양수의 부호를 반대로 해서 표현. 나타낼 수 있는 수의 범위는 Signed magnitude랑 동일.
* 예) +0 = 0000, -0 = 1111 / +3 = 0011, -3 = 1100
* 2’s complement=2의 보수 : 1의 보수에 +1. 위 2개와는 달리 +0, -0의 구분 없이 둘 다 0000이다. 그 덕분에 음수 하나를 더 나타낼 수 있다. n비트로 -2n-1 ~ 2n-1 - 1 까지의 정수 표현 가능.

**컴퓨터에서의 정수 연산**  

* 1의 보수 연산 : 빼기 연산은 음수를 더하는 것으로 계산 (7 - 5 = 7 + (-5)). end-around carry 주의.

*To add two numbers represented in this system, one does a conventional binary addition,* ***but it is then necessary to do an end-around carry: that is, add any resulting carry back into the resulting sum.*** *To see why this is necessary, consider the following example showing the case of the addition of −1 (11111110) to +2 (00000010):*  

```
          binary    decimal
        11111110     –1
     +  00000010     +2
     ───────────     ──
      1 00000000      0   ← Not the correct answer
               1     +1   ← Add carry
     ───────────     ──
        00000001      1   ← Correct answer
```

*In the previous example, the first binary addition gives 00000000, which is incorrect.* ***The correct result (00000001) only appears when the carry is added back in.***  

* 2의 보수 연산 : carry 무시. 그냥 계산해도 답 나온다.

(2의 보수 연산이 더 쉽기 때문에 대부분의 컴퓨터에서 2의 보수를 사용한다.)  

**컴퓨터에서의 실수 표현 : floating point**  
*부동 소수점 표현 방식은 수를 (가수)×(밑수)(지수)와 같이 유효숫자를 사용한 곱셈 형태로 표현한다. 예를 들어, -0.4를 밑수가 10인 부동 소수점으로 나타내면 -0.04×101이 되며 밑수가 2이면 -0.8×2-1가 되는데, 가수 부분을 한자리 자연수를 갖도록 바꾸면 -4×10-1과 같이 된다. 이처럼 가수의 첫째 자리가 밑수보다 작은 한자리 자연수가 되도록 바꾸는 것을 정규화라고 한다. 예를 들어, 앞의 값은 밑수가 2이면 -0.8×2-1이 되는데 이것을 정규화하면 -1.6×2-2이 된다. (여기서 볼 수 있듯이 밑수가 2일 때 정규화하면 가수부분의 첫째 숫자는 항상 1이 된다.)*  
부동 소수점 표현 방식 예) 3.14 = 3.14 * 100 = 31.4 * 10-1 = 415.0 * 10-2 = 0.314 * 101 = 0.0000000314*108 = ...  

정규화=normalization : 소수점이 있는 모든 실수의 소수점을 이동하여 정수 부분을 0으로 만들고, 소수점 아래 첫 번째 수는 반드시 0이 아닌 수가 오도록 만든다.  
ex) 1101.001 => 0.1101001 * 24  
    125.64 => 0.12564 * 103  

(+/-) M * B^((+/-)E)  
(M=Mantissa, B=Base, E=Exponent)  

ex) 십진수 -25.458은 이진수로 표현하면 -11011.0111이다. 정규화를 수행하면 -0.25458 * 102로 변환되고, 크기 부분은 0.25458이며, 지수 부분은 2이다. 그러므로 정규화한 이진수는 -0.110010111 * 25이다. 마찬가지로 실수의 부호는 -이고, 크기 부분은 0.110010111이고, 지수는 5이다.  

절단오차가 생긴다. 실수 연산에서는 그 값이 항상 근사값일 수밖에 없다.  

**소리의 표현**  
아날로그 => 샘플링 => 디지털  

**이미지(영상)의 표현**  

--------

## Chapter 9. 컴퓨터 시스템 조직

p.229 그림 9.1 내장 프로그램 컴퓨터 조직  
Memory <===> CPU=Central Processing Unit (CU=Control Unit + ALU=Arithmetic & Logic Unit) <===> I/O장치  

p.229 그림 9.2 컴퓨터 시스템 조직과 정보의 흐름  

프로그램 내장방식에 따라, 명령어들이 처음에는 Memory에 들어 있다. 이것들을 필요할 때 CPU로 가져와서 처리한다. 그 때 CPU 안에도 작은 메모리가 필요하다. 그것이 바로 Cache, Register.  

**메모리 계층 구조=Memory Hierarchy : 여러 종류의 메모리를 계층적으로 서로 연결한 구조.**  
*메모리 계층 구조(Memory hierarchy)란 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다. 이때 필요란 대부분의 경우 CPU가 메모리에 더 빨리 접근하기 위함이다.*  
*레지스터와 캐시는 CPU 내부에 존재한다. 당연히 CPU는 아주 빠르게 접근할 수 있다. 메모리는 CPU 외부에 존재한다. 레지스터와 캐시보다 더 느리게 접근 할 수 밖에 없다. 하드 디스크는 CPU가 직접 접근할 방법조차 없다. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다. 아주 느린 접근 밖에 불가능하다.*  

<!--
{{< figure src="https://upload.wikimedia.org/wikipedia/commons/c/c6/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EA%B7%B8%EB%A6%BC1.png" width="300px" >}}
-->

위로 갈수록 속도가 빠른 대신, 가격이 비싸고 용량이 적다.  
아래로 갈수록 속도가 느린 대신, 가격이 싸고 용량이 많다.  

메모리 계층 구조가 왜 존재하는가? speed와 cost를 절충할 필요가 있기 때문. 싸고 빠른 컴퓨터를 만들어야 한다. 캐시를 무한정 늘리면 속도가 빨라지니 좋지만, 당연히 비용이 비싸진다. 이 메모리들 간의 절충이 필요하다.  
*메모리 계층 구조는 '어떻게 하면 최대한 저렴한 가격에 최대한 빠른 컴퓨터를 만드는가?'라는 질문에 대한 대답에서 출발한다. 싼 메모리는 용량이 크지만 느리고, 비싼 메모리는 용량이 작지만 빠르다. 대부분의 컴퓨터 프로그램들은 프로그램의 작은 부분에 자주 접근하기에, 그 작은 부분만을 비싼 메모리에 저장하고 사용하면 프로그램의 전체적인 성능이 향상된다. 이 때문에 컴퓨터 메모리는 용량이 많고 느린 아래쪽에서 시작해서 용량이 작고 빠른 위쪽으로 올라가는 계층구조를 지니고 있다. 이를 '메모리 계층 구조'라 한다.*  

machine language, assembly language, high-level language  

assembler : assembly language => machine language  
compiler : high-level language => machine language  

컴퓨터가 알아들을 수 있는 건 machine language밖에 없다.  

3-address instruction : ADD X, Y, Z : (X + Y)의 결과를 Z에 넣어라.  
2-address instruction : ADD X, Y : (X + Y)의 결과를 Y에 넣어라.  
1-address instruction : ADD X : (X + R)의 결과를 R에 넣어라. R 내용은 실행하기 전에 이미 메모리에서 가져와 탑재했다.  
0-address instruction :   

--------

**중요한 부분만 공부하자. 쓸데없는 곳에서 혼자 막히지 말자. 책 내용을 다 이해하려 하지 말자.**  

메모리 계층 구조 복습. 레지스터 > 캐시 > 메모리 > HDD  
그 중 레지스터를 기능에 따라 다시 분류할 수 있다.  

레지스터 종류 | 레지스터 기능
--- | ---
연산용 레지스터=Arithmetic Register=AR | 연산장치의 모든 연산에 입출력되는 자료를 임시로 보관. CPU 내에 하나뿐일 경우 누산기=Accumulator=AC라고 한다.
프로그램 계수기=Program Counter=PC | 다음에 수행해야 할 명령의 주소 저장.
명령어 레지스터=Instruction Register=IR | 현재 수행하고 있는 명령어 보관.
기억장치 주소 레지스터=Memory Address Register=MAR | 현재 수행하는 명령이나 자료를 읽거나 쓰는 데 필요한 기억장치의 주소를 보관.
기억장치 자료 레지스터=Memory Buffer Register=MBR (Memory Data Register=MDR) | 기억장치와 CPU 사이의 자료교환 시 임시로 자료를 보관.

*의문 : (이것들이 모두 cpu 내에 있는 것인가?)*  

p.262 패치 -> (해석) -> 실행  
명령어를 가져와서(FETCH) (해석해서 (INTERPRET)) 수행하는(EXECUTE) 단계 : (AR) -> PC -> MAR -> MBR -> IR  
*PC의 주소를 MAR에 넣는다. 그리고 MAR의 주소로 패치를 수행한다. 그러면 주소가 가리키는 셀의 내용을 MBR에 복사한다. MBR에 있는 인스트럭션을 IR에 넣는다. 그러면 해석 단계에서 해석할 준비가 된다. 그리고 PC의 내용을 증가시키고 다시 PC에 넣는다. 이 PC에 들어있는 값이 다음 실행할 인스트럭션의 메모리 주소이다.*  
*이제 제어기 장치는 IR에 현재 실행할 인스트럭션을 가지고 있으며, PC를 갱신했다. 그러면 현재 실행 중인 인스트럭션이 실행을 마치면, PC안에 있는 다음 인스트럭션을 다시 패치한다. 그리고 해석하고 실행할 준비를 한다.*  
INTERRUPT : 현재 F-E 중지하고 다른 F-E 주기 실행  

큰 프로그램 수행하는 법 : 주기억장치(램) 크기보다 프로그램 크기가 더 클 때는, 보조기억장치(HDD)에서 필요한 부분만 page 단위로 램에 가져와서 실행.  
그래서 램이 클수록 컴퓨터 속도가 빠른 것.  
*가상 메모리는 RAM을 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.*  
*이러한 방식은 멀티태스킹 운영 체제에서 흔히 사용되며, 실제 주기억장치보다 큰 메모리 영역을 제공하는 방법으로도 사용된다.*  

p241 그림 9.7 제어장치의 레지스터와 인스트럭션 해석기 구성 요소  
*의문 : 버스?*  

p243  
*의문 : MAR, MBR 차이점?*  

주기억장치 : RAM=Random Access Memory : R/W 가능. Random Access 접근 방식 : 메모리의 어느 위치에 있는 자료(데이터/인스트럭션 등)라도 접근하는 시간은 균등하게 일정하다.  
ROM=Read Only Memory : 내용 변경 불가. (ROM도 접근방식은 Random Access)  

p254 입출력 방법 : 프로그램에 의한 입출력 방식, 인터럽트에 의한 입출력 방식. 자세히 X. 이런 것들이 있다.  

p258 탐색시간, 지연시간, 전송시간. 하드디스크 플래터 돌 때 시간 걸린다. Random Access와 구별.  

p261 그림 9.19: 종합  

p265 새로운 개념의 컴퓨터 시스템  
병렬 컴퓨터 : 처리기가 여러 개. 여러 개의 인스트럭션을 동시에 처리.  
데이터 플로우 컴퓨터 : 데이터의 관점에서 컴퓨터의 흐름을 생각. (기존에는 인스트럭션 중심)  
광 컴퓨터 : 전류의 흐름이 아닌 빛으로 처리.  

양자 컴퓨터 : 큐비트(최소 단위)의 중첩이라는 특성을 이용. (1과 0의 두 가지 상태를 동시에 나타낼 수 있음)  

--------

프로그램을 디자인 == 자료구조를 디자인  
자료구조와 알고리즘은 밀접한 관계가 있다.  
대표적 자료구조:  

* stack : LIFO  
* queue : FIFO  
* tree  
* graph  
* linear list  

instruction에 필요한 address가 적을수록, 똑같은 작업이라도 명령이 많이 필요하다. 0-address instruction만을 사용하는 경우와 다른 경우를 비교해 보자.  

* translator (compiler, assembler) : 원시코드 -> 기계어 -> 실행 (기계어 코드는 한번 만들어두면 계속 실행가능)  
* interpreter : 원시코드 -> 실행 (매번 직접 실행)  

--------

모든 프로그래밍 언어는 연산자 우선순위와 계산방향이 정해져 있다.  

* 연산자 우선순위=operator priority (1순위: 괄호, 2순위: 곱셈/나눗셈, ...)  
* 계산방향=associativity (좌->우, 우->좌)  

연산자 표기법 3가지  

**infix notation**  

* ex) 3+4 (그냥 평소에 쓰는 것)

**prefix notation**  

* ex) 3+4 => + 3 4
*      (5-6)x7 => x - 5 6 7
*      5-(6x7) => - 5 x 6 7

**postfix notation**  

* ex) 3+4 => 3 4 +
*      (3-4)x5 => 3 4 - 5 x
*      3-(4x5) => 3 4 5 x -

**컴퓨터 내부 계산에서는 postfix notation을 쓴다. 앞에서부터 읽어서 stack에 순서대로 박아서 계산하면 된다.**  
**stack이라는 자료구조를 쓴다는 것이 포인트.**  
infix -> prefix, infix -> postfix 변환 숙지해 둘 것  

p.90 소프트웨어 개발 라이프 사이클  

1. 구현 전 단계 (타당성 검토, 문제 분석, 프로그램 설계, 알고리즘 선택)
2. 구현 단계 (코딩, 디버깅)
3. 구현 후 단계 (테스팅, 검증, 벤치마킹, 문서 작업, 유지보수)

좋은 프로그램이란?  

* 이해하기 쉬움
* 수정이 용이
* Sequential (GOTO x)
* Modulize => 작은 부분(모듈)부터 완성시켜서 전체 프로그램을 완성
* Documentation (Comment) => 주석만 봐도 무슨 동작을 하는지 알 수 있도록

Modulize, Documentation을 잘 해 두면 나중에 Debugging, 수정에 유리하다.  

한글 오토마타 프린트 공부할 것  

--------

## Chapter 4 고급 언어의 번역: 컴파일러

**컴파일러, 인터프리터 차이 복습**  

* 컴파일러 : 고급 언어 -> 기계어 -> 실행
* 인터프리터 : 고급 언어 -> 실행

한 번 수행하는 시간은 인터프리터가 더 짧을 수도 있지만, 똑같은 코드를 여러 번 수행할 때는 컴파일러가 유리하다.  
컴파일러는 기계어로 한 번 컴파일해 두면 여러 번 실행할 수 있지만, 인터프리터는 실행할 때마다 고급 언어를 번역해야 하므로.  

**어셈블리어와 기계어는 일대일 대응** => 한 개의 어셈블리어 인스트럭션은 한 개의 기계어 인스트럭션을 생성.  
ex) ADD X, A => 심볼 테이블에서 ADD를 찾고, X, A 주소값을 계산하여 => 0101 000010 010111  
(심볼 테이블 : ADD=0101, SUB=0001, ...과 같이 어셈블리어 심볼 주소값 담아둔 것)  

One-pass / Two-pass assembler  

* One-pass assembler : 어셈블리 코드를 처음부터 한 번에 쭉 스캔해서 끝낸다.
* Two-pass assembler : 어셈블리 코드를 한 번 훑고, 다시 처음부터 쭉 스캔한다. 총 2번 스캔한다.

One-pass에서는 ADD A, B; A 1; B 2; 같은 코드를 쓸 수 없다. 무조건 할당문을 먼저 써 줘야 한다.  
대부분 Two-pass를 쓰지만, One-pass로도 불가능한 건 아니다.  

절대주소, 상대주소 => 상대주소는 번역할 때 링커가 절대주소로 바꿔준다.  

Virtual memory 복습 : 주기억장치의 용량에는 한계가 있다. 큰 프로그램을 수행할 때에는, 보조기억장치에서 프로그램 일부를 page 단위로 계속 가져와서 사용한다.  
이차원 배열 접근법 2개 : **컴퓨터는 이차원배열도 일차원배열처럼 다룬다.**

* Row-major : 행 단위로 읽는 것 => **page 단위로 나눌 때 행 단위로 가져온다.**
* Column-major : 열 단위로 읽는 것 => **page 단위로 나눌 때 열 단위로 가져온다.**

사용하는 언어에서 배열을 어떻게 다루는지 잘 파악해야 한다.  
ex) Row-major 언어에서 page를 행 단위로 가져온다 할 때, 배열 iteration을 열 방향으로 (세로로) 쭉 도는 것과 행 방향으로 (가로로) 쭉 도는 것은 수행 시간 차이가 많이 난다. 생각해보자.  

할당문 : A = B + C;  

미니파스칼 프린트 공부할 것  

**Chomsky Hierarchy**  

* Type 0 : Unrestricted Grammar
* Type 1 : Context-sensitive Grammar
* Type 2 : Context-free Grammar => Push-down Automata
* Type 3 : Regular Grammar => Finite Automata

컴파일러 단계 : **어휘분석 단계** (스캐너) -> **구문분석 단계** (파서) -> **의미분석 단계** (중간코드 생성기) -> **코드 생성 단계** (코드 생성기) -> **최적화** (최적화기)  

**어휘분석 단계** : 스캐너가 입력된 문자열을 토큰으로 쪼개고, 토큰을 유형에 따라 분류.  

* **스캐너** : 어휘 분석을 수행하는 모듈. **Finite Automata**의 일종. 따라서 어휘분석은 **Type 3 : Regular Grammar** 사용.
* **토큰** : 고급언어에서 의미를 가지는, 더 이상 쪼갤 수 없는 가장 작은 단위

ex) area = b + 3.14 * radius; -> ['area', '=', 'b', '+', '3.14', '*', 'radius', ';']  

**구문분석 단계** : 어휘분석 단계에서 생성한 토큰에 대하여 문법적으로 맞는지 아닌지 분석. 프로그램 문장이 잘 작성되었는지를 파악하고 문법적으로 옳은지 아닌지를 결정.  

* **파스 트리** : 어떤 문장이 문법에 맞는지 검사하기 위해 문법을 대조하는 구조. 완전한 파스 트리가 생성되면 이 문장은 해당 프로그래밍 언어의 규칙에 따라 정확하게 작성된 것으로 판단한다. 그러나 파서가 완전한 파스 트리를 생성하지 못하거나 도중에 생성할 수 없는 상황이 되면 이 문장은 문법에 맞지 않는다고 판단한다.
* **파서**는 **Push-down Automata**의 일종. 따라서 구문분석은 **Context-free Grammar** 사용.
* **Grammar**는 여러 개의 **Production**들로 이루어져 있고, 한 Production은 **넌터미널** 또는 **터미널**로 이루어져 있다.
* **넌터미널** : 프로그램에 사용하는 토큰이 아니고, 문법 규칙을 설명하기 위해 사용하는 기호. 보통 대문자로 표기
* **터미널** : 프로그램 작성 시에 사용하는, 스캐너가 인식하고 분석하는 토큰. 보통 소문자로 표기
* **시작 넌터미널** : 모든 것의 시작
* BNF 표기법 : Grammar를 표현하는 방법 중 하나. <수식> ::= "수식의 정의" | <심볼> + <심볼> | ...
* 좌파스, 우파스 정리한 것 공부할 것

의미분석 단계  

코드 생성 단계  

최적화  

* 시간 단축 최적화 : 실행 시간 단축
* ex) a = b * 3; 문장은 곱하기 연산으로 인해 실행 시간이 많이 들 수 있다. 곱하기 연산은 더하기 연산보다 계산 과정이 많이 걸리기 때문. 따라서 곱하기 연산 대신 더하기 연산을 사용하여 a = b + b + b; 와 같이 최적화시킬 수 있다.
* 공간 단축 최적화 : 차지하는 메모리 공간 줄이기

--------

## Chapter 05. 시스템 소프트웨어와 가상기계

컴퓨터 하드웨어 복습  

* CPU = ALU + CU 
* 레지스터 : CPU 내부에 존재하는 기억장치. 기능에 따라 종류가 여러 개 있는데, 그 중 자주 쓰이는 것들은 이름을 붙인 것. (AR, PC, IR, MAR, MBR 등)
* 캐시 : CPU 내부에 존재하는 기억장치. 주기억장치에서 레지스터로 프로그램을 가져올 때, 필요할 때 가져오면 늦으니까 미리 가져와두는 곳.
* 주기억장치, 보조기억장치 : CPU 외부에 존재.
* 가상 메모리 : 보조기억장치에 주기억장치의 내용 일부를 전달해 읽고 쓰는 방식. 주기억장치 용량 부족 해소.

**캐시와 가상메모리를 구분할 것.**  

* 캐시 : CPU 내부에 물리적으로 존재. 주기억장치의 속도 보완 목적.
* 가상메모리 : 실제로 없고, 소프트웨어적으로 구현한 것. 주기억장치의 공간을 가상적으로 넓히기 위한 것.

Memory Hierarchy 복습  

* 속도 빠름, 비용 높음 : 레지스터 > 캐시 > 주기억장치 > 보조기억장치


**시스템 소프트웨어** : 하드웨어의 원리를 모르더라도 컴퓨터를 쉽게 활용하도록 해 준다.  

* 우리가 보는 컴퓨터는 시스템 소프트웨어다 (가상 기계). 하드웨어를 시스템 소프트웨어라는 껍데기가 감싸고 있는 것.
* 사용자는 외부 인터페이스를 통해 시스템 소프트웨어와 상호작용하고, 시스템 소프트웨어는 내부 인터페이스를 통해 하드웨어와 상호작용한다.
* 하드웨어의 복잡한 내부구조를 사용자에게 보여주지 않는다.
* 중요한 정보를 사용자가 알기 쉽게 보여준다.
* 사용자가 컴퓨터의 각종 자원에 간단하고 효율적으로 접근하도록 한다.

시스템 소프트웨어의 종류는 다양하다.  

* 운영체제 : 가장 중요한 시스템 소프트웨어. 사용자와 상호작용하며 사용자가 무엇을 원하는지 결정하고, 사용자의 요구에 따라 다른 프로그램을 구동시킨다.
* 사용자 인터페이스 : 최근에는 GUI 사용
* 텍스트 에디터, 파일 시스템, 번역기, 스케쥴러, 메모리 관리자, 디버거 등

p.131 그림 5.3 어셈블리어 명령어 일부. CPU마다 다르다.  
어셈블리어: 메모리 주소를 심볼(레이블)로 표현할 수 있다. =>   

* 프로그램이 메모리의 어느 위치에서 시작하든지, 프로그램에서 해당 인스트럭션의 상대적인 위치는 변화가 없다.
* 프로그램이 메모리의 어느 위치에 있더라도 주소값을 수정할 필요가 없다.

--------

어셈블리어 명령어 주어지고, 프로그램 해석하기.

## Chapter 06. 운영체제

(용어 중심 정리)  

* 배치 시스템(일괄 처리 시스템) : 프로그램, 데이터 여러 개를 하나로 묶어서 한번에 일괄적으로 처리. 효율 좋음. (<==> 실시간 시스템)
* 시분할 시스템 (time-sharing) : 아주 작은 시간동안 여러 프로그램을 돌아가면서 실행 -> 여러 개의 프로그램을 동시에 실행 가능
* 실시간 시스템
* 임베디드 시스템 : 특수한 목적에 따라 기기를 제어하는 프로그램이 실행되도록 어떤 기기에 내재된 운영체제
* 모바일 시스템
* 분산 시스템 : 여러 지역으로 떨어져 있는 컴퓨터 시스템이 네트워크로 연결되어 있는 것
* 클라이언트-서버 시스템 : 분산 시스템 중 하나, 클라이언트 - 인터넷 - 서버
* 피어-피어 시스템 : 분산 시스템 중 하나, 클라이언트와 서버의 구별이 없다. 클라이언트끼리 인터넷으로 연결되어 있음.
* 클라우드 시스템

HCI(인간-컴퓨터 상호작용) : 라인 명령어 입력 방식 / 그래픽 기반 입력 방식  

Multi processing (다중 작업) : 여러 개의 작업을 동시에 수행  
인터럽트 : 프로그램 실행 중 다른 장치나 소프트웨어에서 발생하는 신호. 실행하던 프로세스 중지 후 중요도에 따라 필요한 다른 작업 수행, 또는 하던 작업 수행  
동기화 : 프로세스 사이에서 통신을 통해 이루어짐. 특정 DB를 여러 프로세스가 동시에 접근하려 하면 데이터를 동시에 사용할 수 없다. => 순서를 정해 어떤 프로세스를 먼저 접근하도록 한다.  

--------

## Chapter 07. 컴퓨터 네트워크와 인터넷

네트워크의 장점  

* 여러 개의 노드가 연결되어 있으므로, 노드 하나만 있을 때의 한정된 능력을 향상시켜 줌
* 경로 몇 개가 파괴되더라도 다른 경로 존재

(용어 중심 정리)  

* LAN : 근거리 통신망.
* 변조 (Modulation) : 신호를 멀리 보낼 수 있도록 신호를 변환
* 복조 (Demodulation) : 변조된 신호를 다시 되돌림
* 모뎀 (MODEM) : 변조, 복조를 수행하는 기기
* bps (bits per second) : 신호의 속도
* 광대역 (Broadband) : 고속 통신 기술
* 무선 통신, 모바일, Wi-Fi, Bluetooth

근거리 네트워크의 유형  

* 별 구조 : 중앙집중식 => 한 곳이 파괴되면 손해 큼
* 완전 연결 구조 : 분산형 => 한 곳이 파괴되어도 괜찮다

패킷통신(Packet communication) : 정보 한 개를 여러 개의 패킷으로 쪼개어, 경로 여러 개를 통해 전송. 수신자는 패킷을 모두 받으면 모아서 한 개의 정보로 재구성.  
경로 몇 개 파괴되더라도 네트워크 전체가 고장나지는 않는다.  

인터넷 : 패킷통신의 장점 + 분산형 네트워크의 장점  

TCP/IP (Transmission Control Protocol : 네트워크 상에서 돌아다니는 패킷을 제어하는 규약 / Internet Protocol : 네트워크의 구성 규약) : 인터넷 프로토콜 계층 구조  

계층 | 이름 | 하는 일  
--- | --- | ---  
5 | 응용 계층 | HTTP, SMTP, FTP  
4 | 수송 계층 | TCP, UDP  
3 | 네트워크 계층 |  IP  
2b | 논리 링크 제어 계층 | PPP, 이더넷  
2a | 매체 접근 제어 계층 | 이더넷  
1 | 물리 계층 | 모뎀, DSL, 케이블 모뎀, 와이파이, 3G  

2a, 2b, 3 : 데이터 링크 계층  

라우팅(라우트) : 데이터를 보낼 경로를 선택하는 과정  
IP : 각 노드에 보통 4바이트의 아이피 주소 부여  

--------

참고 및 출처  

* https://ko.wikipedia.org/wiki/%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1_%EC%9D%B4%EB%A1%A0#%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%B5%ED%95%99
* https://namu.wiki/w/%ED%8F%B0%EB%85%B8%EC%9D%B4%EB%A7%8C%20%EA%B5%AC%EC%A1%B0
* https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84
* https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-omega-notation
* https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation
* https://hahasof.tistory.com/5
* https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%EA%B2%80%EC%83%89_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
* https://ko.wikipedia.org/wiki/%ED%8C%A8%EB%A6%AC%ED%8B%B0_%EB%B9%84%ED%8A%B8
* https://en.wikipedia.org/wiki/Signed_number_representations
* https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90
* https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0
* https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%20%EA%B5%AC%EC%A1%B0
* https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC

