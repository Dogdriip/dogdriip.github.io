---
title: "[2018_1] 컴퓨터학개론"
date: 2019-06-30T20:48:32+09:00
draft: false
---

2018-1에 들었던 컴퓨터학개론

한번 쭉 읽으면서 마크다운 문법만 적용시켰다

--------

## 1장

과학과 공학의 차이? 당연히 사람마다 견해가 다르다.  

* Computer Science : Input, Output으로부터 Process를 유추해서 설명하는 것. Process는 만들어 낸 것이 아닌 이미 있는 것.  
* 만유인력은 임의로 만들어 낸 것이 아니다. 가만히 있었는데 사과가 떨어졌다는 IO로부터 만유인력이라는 P를 유추.  
* Computer Engineering : 우리가 생각하는 Input, Output이 나오도록, Science의 결과를 이용하여, 필요에 맞게 Process를 설계, 구현, 보완  

Computer가 무엇인지 정의해 봐라 => 사람마다 견해가 다르다.  
P. 4 / Computer Science의 정의 : “어떤 문제를 해결하기 위해 알고리즘을 설계하고 개발하는 일련의 과정” => 완벽한 정의는 아닐 수도 있다는 이야기.  

(공학도로써 지켜야 할, 추구해야 하는 목적 2가지. 문제해결능력, 소통(커뮤니케이션))  

**Definition of Algorithm** : 특정한 작업을 수행하는 명령어들의 유한집합=A finite set of instructions that, if followed, accomplishes a particular task.  
알고리즘이 만족시켜야 할 기준, 규범=criteria 5가지  

1. Input : 0개 이상 (Input이 없는 알고리즘의 예: 원주율의 n번째 자리는?)
2. Output : 1개 이상
3. Definiteness : 각 명령=instruction은 명확하고, 모호하지 않아야 한다. 누가 들어도 똑같이 알아먹어야 한다.
4. Finiteness : 알고리즘은 유한한 단계 후에, 모든 경우에 대해 어떻게든 끝나야 한다.
5. Effectiveness : (수행 가능성?) 모든 명령어들은 원칙적으로 종이와 연필만으로 수행될 수 있을 정도로, 현실적으로 실행이 가능해야 함. 각 명령은 (3)처럼 분명해야 하지만, 실행도 가능해야 한다.

*(5) Effectiveness는 알고리즘의 효율성이 아니다. 알고리즘의 효율성은 시간 복잡도 개념으로 들어간다.*  
*충분한 시간과 종이, 연필만 있으면 정확히 계산할 수 있어야 한다.*

운영체제는 알고리즘이라 할 수 없다. 4. Finiteness 충족X  
*참고 : 구글검색 is an operating system an algorithm*

Algorithm의 궁극적 목적 : **Optimial solution=최적해를 구하는 것.** but 시간이 오래 걸림.  
일부를 포기하고 sub-optimal solution=준최적해를 취해야 할 때도 있다.  
Algorithmic solution 이외에도 **Heuristic problem solving도 고려할 필요가 있다.**  
*컴퓨터 공학에서 발견법은 해결법이 정확히 해결되는지에 대한 문제를 무시하고 일반적으로 좋은 해결법이나 보다 간단한 해결법으로 풀고자 하는 문제 해결법이다. 예를 들어 상업적인 컴퓨터 바이러스 검색 소프트웨어들은 발견법으로 특정 속성이나 특징들을 찾아 바이러스나 나쁜 소프트웨어를 찾아낸다. 하지만 잠재적인 정확도 하락의 요인이 되기도 한다.*

speed=속도, cost=비용(시간 등) => 이 2개로 각종 시스템의 장단점 비교 가능. 2개 단어 알아둘 것. 비교할 때 2개만 알아두면 됨.

폰 노이만 : **stored-program computer (내장 프로그램 컴퓨터)**이라는 새로운 개념의 컴퓨터 시스템을 만듦. 명령어를 메모리에 넣어두고 필요할 때 꺼내 수행하는 방식. 지금까지도 이 뼈대를 벗어나지 못하고 있음.

* p.10 / 폰 노이만이 제안한 컴퓨터는 동작을 제어하는 인스트럭션을 이진 값으로 코드화하여, 데이터와 함께 메모리 안에 저장하도록 하는 시스템이다. 즉, 새로운 문제를 풀기 위해 이전과는 달리 기계 작동을 처음부터 새로 세팅하지 않는다. 다만, 인스트럭션의 순서만 다시 배열하도록 한다. 다시 말해서 프로그램을 만드는 것이다.
* 프로그램에서 사용하는 데이터와 프로그램 그 자체가 똑같은 형태로 메모리 저장공간을 점유하다 보니 데이터를 처리할 때와 같은 방법으로 새로운 프로그램을 만들 수 있고, 기존 프로그램을 변경할 수도 있다는 거죠. 쉽게 말해서 기존 물리적인 방법과 다르게 (초기에는 천공 테이프, 진공관 등 물리적인 방법으로 프로그램을 작성했음) 프로그램을 이용한 프로그래밍이 가능하게 되었고, 하드웨어 구현에 대한 전문지식이 없어도 원하는 프로그램을 작성할 수 있다는 거죠.
* 이 구조의 특장점을 꼽자면, 컴퓨터에 다른 작업을 시키려고 할 때 굳이 하드웨어(전선)를 재배치할 필요 없이 소프트웨어(프로그램)만 교체하면 되기 때문에 범용성이 크게 향상된다는 것이다. 전선을 일일이 교체할 경우 교체인원도 많이 필요하고 시간도 많이 잡아먹는 등 여러모로 불편함이 있지만(그 이전의 컴퓨터들은 스위치를 설치하고 전선을 연결하여 데이터를 전송하고 신호를 처리하는 식으로 프로그래밍하였다), 폰 노이만 구조를 도입하면 프로그램을 교체하는 것으로 모든 일이 끝난다. 이 엄청난 편의성 때문에, 현재 거의 모든 컴퓨터들은 폰 노이만 구조를 따르고 있다.

--------

## 2장

알고리즘을 표현할 수 있는 방법은 많다. (자연어, 순서도, 프로그래밍 언어, pseudo code, ...)  
알고리즘에서의 여러 요소 : 순차 동작, 조건 동작, 반복 동작  

**알고리즘의 우열? 시간 복잡도=Time Complexity**  
**문제의 크기가 n일 때, 이 문제를 푸는 데에 걸리는 시간**  

**수행 시간 : O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n)**  
**(상수 시간=constant < 로그 시간 < 선형 시간=linear < 선형 로그 시간 < 2차 시간=cubic < 지수 시간=exponential)**  

**Big-O Notation : O(n) (Order of n) => gives upper bound**  
*알고리즘의 시간복잡도는 주로 빅-오 표기법을 사용하여 나타내며,* ***이 빅-오 표기법은 계수와 낮은 차수의 항을 제외시키는 방법이다.*** *이런 방식으로 표현할 때, (예를 들면, 입력 크기를 무한대로 입력하여) 시간복잡도를 점근적으로 묘사한다고 말한다.*  
*예시로서, 만약 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 (어떤 n_0보다 크지 않은 모든 n에 대하여) 5n^3 + 3n의 식을 가진다면, 이 알고리즘의 점근적 시간 복잡도는 O(n^3)이라고 할 수 있다.*

**Omega Notation : Ω(n) (Order of at least n) => gives lower bound**  
*때로는 알고리즘이 상한선 없이 최소한 어느 정도 걸린다고 해야 할 때도 있을 것입니다. 그럴 때는 big-Ω 표기법을 사용합니다. 여기서 Ω는 그리스 문자 "오메가"입니다.*  

**Theta Notation : Θ(n) => gives both lower and upper bound**  
*중요한 것은 선형 검색의 최악의 경우의 실행 시간은 배열 크기인 n에 따라 커진다는 것입니다. 여기서 실행시간을 표시하기 위해 사용하는 표기법은 Θ(n)입니다.*  

**Best-case, Worst-case, Average-case**  
예) 순차 검색 : Best-case = O(1), Worst-case = O(n), Average-case = O(n/2)  
**어떤 알고리즘의 시간복잡도를 묻는 것은, Worst-case의 경우를 묻는 것이다.**  
*그렇다면 알고리즘마다 세가지의 경우를 모두 고려해야 할까? 그렇지 않다. 일단 Best-case는 고려해야 할 대상이 아니다. 어떤 알고리즘이던 Best-case는 1이기 때문이며 비현실적인 경우이기 때문이다. 그리고 Average-case는 고려하기에 애매하다. 위의 경우는 원하는 대상이 탐색 대상에 있을 확률을 50%라고 정했지만 세상의 모든 자료들이 50%확률로 탐색대상에 있을 것이라 단정지을 수 없다. 그리고 탐색대상에 있다 하더라도 n/2라는 수치는 근사치이기 때문에 '이 알고리즘의 시간복잡도는 n/2'라 표현하기가 뭐하다.* ***따라서 시간복잡도를 표현할 때는 Worst-case만을 이야기한다.***  

### Search

* 순차 검색=Sequential search : 첫 레코드부터 내가 원하는 자료가 나올 때까지 순서대로 탐색 => O(n)
* **이진 검색=Binary search** : (In ascending-sorted list) 중앙값이 원하는 값보다 큰가? 반씩 쪼개기의 힘. => O(log n)

*이진 검색 알고리즘(binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최고값이 되며, 작으면 그 값은 새로운 최하값이 된다. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다.*  
참고 : O(log n) (로그 시간)  
*이런 타입의 가장 쉬운 예제 알고리즘은, 문자열을 절반으로 쪼개어 그 오른쪽의 문자열을 다시 또 절반으로 쪼개고, 이를 반복하는 알고리즘으로 생각할 수 있다. 이 알고리즘은 우리가 각각의 출력 이전에 문자열을 절반으로 나누기 때문에, O(log n)시간 (n은 문자열의 길이) 이 소요된다. 이것은 출력 횟수를 증가시키기 위해서는 문자열의 길이를 두배로 늘려야 함을 의미한다.*  

### Sort

**(by compare & interchange)**

* Merge sort => O(n log n)
* (Heap sort)
* Selection sort => O(n^2) (최악의 경우의 비교 횟수를 생각해 보면, n(n-1)/2라는 걸 알 수 있다.)

**NOT by compare & interchange**

* Address calculation sort : 각 값을 메모리 주소에 할당 후 나중에 주소값 순서대로 읽음. 데이터 간 비교 없음. => O(n)

--------

## Chapter 10. 자료의 표현

bit : 컴퓨터에서 숫자를 나타내는 최소 단위  
byte : 8 * bit  

**문자의 표현**  
ASCII (7bit 이용, 나머지 1bit는 parity bit로 활용)  

*패리티 비트(Parity bit)는 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트이다. 전송하고자 하는 데이터의 각 문자에 1 비트를 더하여 전송하는 방법으로 2가지 종류의 패리티 비트(홀수, 짝수)가 있다. 패리티 비트는 오류 검출 부호에서 가장 간단한 형태로 쓰인다.*  
* *짝수(even) 패리티는 전체 비트에서 1의 개수가 짝수가 되도록 패리티 비트를 정하는 것인데, 이를테면 데이터 비트에서 1의 개수가 홀수이면 패리티 비트를 1로 정한다.*
* *홀수(odd) 패리티는 전체 비트에서 1의 개수가 홀수가 되도록 패리티 비트를 정하는 방법이다.*

오류 검출하는 완벽한 방법은 아니다. 예를 들어, 0000001 -> 0000111처럼 홀, 짝은 유지되지만 오류가 날 수 있다.  

그 외에 EBCDIC, 유니코드 등이 있다.  

Digital / Analog  

Hexadecimal=16진법, Decimal=10진법, Octal=8진법, Binary=2진법  

(표1)  

**10진수 (소수점 포함) -> 2진수 변환**  
정수 부분 : 평소대로 2로 계속 나눠서 나머지만 역순으로 쓴다.  
**소수 부분 : 소수부분 * 2 해서 1보다 작으면 0으로 두고, 1보다 크면 1로 두고 그 수에서 1을 뺀다. 이를 반복한다.**  
ex) 0.458 * 2 = 0.916 => 0  
    0.916 * 2 = 1.832 => 1  
    0.832 * 2 = 1.664 => 1  
    0.664 * 2 = 1.328 => 1  
    0.328 * 2 = 0.656 => 0  
    ...  
ex) 25.458(10) -> 11001.01110… (2)  
    7.25(10) -> 111.01000… (2)  

2진수 -> 8진수, 2진수 -> 16진수는 쉽다.  

* bin -> oct : 2진수 3비트씩 끊어서 생각.
* bin -> hex : 2진수 4비트씩 끊어서 생각.

p.278 10.2 이진수의 표현에 있는거 한번 읽어보기. 진법 간의 변환이 다 나와 있다.

**컴퓨터에서의 정수 표현** => 3가지 방법  

* Signed magnitude : 맨 앞 비트 하나를 부호 표현에 할당(플마). n비트로 -(2n-1 - 1) 부터 2n-1 - 1 까지의 정수 표현 가능.
* 1’s complement=1의 보수 : Signed magnitude랑 양수 부분은 똑같다. 음수 부분은 각각의 양수의 부호를 반대로 해서 표현. 나타낼 수 있는 수의 범위는 Signed magnitude랑 동일.
* 예) +0 = 0000, -0 = 1111 / +3 = 0011, -3 = 1100
* 2’s complement=2의 보수 : 1의 보수에 +1. 위 2개와는 달리 +0, -0의 구분 없이 둘 다 0000이다. 그 덕분에 음수 하나를 더 나타낼 수 있다. n비트로 -2n-1 ~ 2n-1 - 1 까지의 정수 표현 가능.

(표2)  

**컴퓨터에서의 정수 연산**  

* 1의 보수 연산 : 빼기 연산은 음수를 더하는 것으로 계산 (7 - 5 = 7 + (-5)). end-around carry 주의.

*To add two numbers represented in this system, one does a conventional binary addition,* ***but it is then necessary to do an end-around carry: that is, add any resulting carry back into the resulting sum.*** *To see why this is necessary, consider the following example showing the case of the addition of −1 (11111110) to +2 (00000010):*  

(그림1)  

*In the previous example, the first binary addition gives 00000000, which is incorrect.* ***The correct result (00000001) only appears when the carry is added back in.***  

* 2의 보수 연산 : carry 무시. 그냥 계산해도 답 나온다.

(2의 보수 연산이 더 쉽기 때문에 대부분의 컴퓨터에서 2의 보수를 사용한다.)  

**컴퓨터에서의 실수 표현 : floating point**  
*부동 소수점 표현 방식은 수를 (가수)×(밑수)(지수)와 같이 유효숫자를 사용한 곱셈 형태로 표현한다. 예를 들어, -0.4를 밑수가 10인 부동 소수점으로 나타내면 -0.04×101이 되며 밑수가 2이면 -0.8×2-1가 되는데, 가수 부분을 한자리 자연수를 갖도록 바꾸면 -4×10-1과 같이 된다. 이처럼 가수의 첫째 자리가 밑수보다 작은 한자리 자연수가 되도록 바꾸는 것을 정규화라고 한다. 예를 들어, 앞의 값은 밑수가 2이면 -0.8×2-1이 되는데 이것을 정규화하면 -1.6×2-2이 된다. (여기서 볼 수 있듯이 밑수가 2일 때 정규화하면 가수부분의 첫째 숫자는 항상 1이 된다.)*  
부동 소수점 표현 방식 예) 3.14 = 3.14 * 100 = 31.4 * 10-1 = 415.0 * 10-2 = 0.314 * 101 = 0.0000000314*108 = ...  

정규화=normalization : 소수점이 있는 모든 실수의 소수점을 이동하여 정수 부분을 0으로 만들고, 소수점 아래 첫 번째 수는 반드시 0이 아닌 수가 오도록 만든다.  
ex) 1101.001 => 0.1101001 * 24  
    125.64 => 0.12564 * 103  

(+/-) M * B^((+/-)E)  
(M=Mantissa, B=Base, E=Exponent)  

ex) 십진수 -25.458은 이진수로 표현하면 -11011.0111이다. 정규화를 수행하면 -0.25458 * 102로 변환되고, 크기 부분은 0.25458이며, 지수 부분은 2이다. 그러므로 정규화한 이진수는 -0.110010111 * 25이다. 마찬가지로 실수의 부호는 -이고, 크기 부분은 0.110010111이고, 지수는 5이다.  

절단오차가 생긴다. 실수 연산에서는 그 값이 항상 근사값일 수밖에 없다.  

**소리의 표현**  
아날로그 => 샘플링 => 디지털  

**이미지(영상)의 표현**  

--------

## Chapter 9. 컴퓨터 시스템 조직

p.229 그림 9.1 내장 프로그램 컴퓨터 조직  
Memory <===> CPU=Central Processing Unit (CU=Control Unit + ALU=Arithmetic & Logic Unit) <===> I/O장치  

p.229 그림 9.2 컴퓨터 시스템 조직과 정보의 흐름  

프로그램 내장방식에 따라, 명령어들이 처음에는 Memory에 들어 있다. 이것들을 필요할 때 CPU로 가져와서 처리한다. 그 때 CPU 안에도 작은 메모리가 필요하다. 그것이 바로 Cache, Register.  

**메모리 계층 구조=Memory Hierarchy : 여러 종류의 메모리를 계층적으로 서로 연결한 구조.**  
*메모리 계층 구조(Memory hierarchy)란 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다. 이때 필요란 대부분의 경우 CPU가 메모리에 더 빨리 접근하기 위함이다.*  
*레지스터와 캐시는 CPU 내부에 존재한다. 당연히 CPU는 아주 빠르게 접근할 수 있다. 메모리는 CPU 외부에 존재한다. 레지스터와 캐시보다 더 느리게 접근 할 수 밖에 없다. 하드 디스크는 CPU가 직접 접근할 방법조차 없다. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다. 아주 느린 접근 밖에 불가능하다.*  

(그림)  

위로 갈수록 속도가 빠른 대신, 가격이 비싸고 용량이 적다.  
아래로 갈수록 속도가 느린 대신, 가격이 싸고 용량이 많다.  

메모리 계층 구조가 왜 존재하는가? speed와 cost를 절충할 필요가 있기 때문. 싸고 빠른 컴퓨터를 만들어야 한다. 캐시를 무한정 늘리면 속도가 빨라지니 좋지만, 당연히 비용이 비싸진다. 이 메모리들 간의 절충이 필요하다.  
*메모리 계층 구조는 '어떻게 하면 최대한 저렴한 가격에 최대한 빠른 컴퓨터를 만드는가?'라는 질문에 대한 대답에서 출발한다. 싼 메모리는 용량이 크지만 느리고, 비싼 메모리는 용량이 작지만 빠르다. 대부분의 컴퓨터 프로그램들은 프로그램의 작은 부분에 자주 접근하기에, 그 작은 부분만을 비싼 메모리에 저장하고 사용하면 프로그램의 전체적인 성능이 향상된다. 이 때문에 컴퓨터 메모리는 용량이 많고 느린 아래쪽에서 시작해서 용량이 작고 빠른 위쪽으로 올라가는 계층구조를 지니고 있다. 이를 '메모리 계층 구조'라 한다.*  

machine language, assembly language, high-level language  

assembler : assembly language => machine language  
compiler : high-level language => machine language  

컴퓨터가 알아들을 수 있는 건 machine language밖에 없다.  

3-address instruction : ADD X, Y, Z : (X + Y)의 결과를 Z에 넣어라.  
2-address instruction : ADD X, Y : (X + Y)의 결과를 Y에 넣어라.  
1-address instruction : ADD X : (X + R)의 결과를 R에 넣어라. R 내용은 실행하기 전에 이미 메모리에서 가져와 탑재했다.  
0-address instruction :   

--------

**중요한 부분만 공부하자. 쓸데없는 곳에서 혼자 막히지 말자. 책 내용을 다 이해하려 하지 말자.**  

메모리 계층 구조 복습. 레지스터 > 캐시 > 메모리 > HDD  
그 중 레지스터를 기능에 따라 다시 분류할 수 있다.  

레지스터 종류 | 레지스터 기능
---------- |------------
연산용 레지스터=Arithmetic Register=AR | 연산장치의 모든 연산에 입출력되는 자료를 임시로 보관. CPU 내에 하나뿐일 경우 누산기=Accumulator=AC라고 한다.
프로그램 계수기=Program Counter=PC | 다음에 수행해야 할 명령의 주소 저장.
명령어 레지스터=Instruction Register=IR | 현재 수행하고 있는 명령어 보관.
기억장치 주소 레지스터=Memory Address Register=MAR | 현재 수행하는 명령이나 자료를 읽거나 쓰는 데 필요한 기억장치의 주소를 보관.
기억장치 자료 레지스터=Memory Buffer Register=MBR (Memory Data Register=MDR) | 기억장치와 CPU 사이의 자료교환 시 임시로 자료를 보관.

*의문 : (이것들이 모두 cpu 내에 있는 것인가?)*  

p.262 패치 -> (해석) -> 실행  
명령어를 가져와서(FETCH) (해석해서 (INTERPRET)) 수행하는(EXECUTE) 단계 : (AR) -> PC -> MAR -> MBR -> IR  
*PC의 주소를 MAR에 넣는다. 그리고 MAR의 주소로 패치를 수행한다. 그러면 주소가 가리키는 셀의 내용을 MBR에 복사한다. MBR에 있는 인스트럭션을 IR에 넣는다. 그러면 해석 단계에서 해석할 준비가 된다. 그리고 PC의 내용을 증가시키고 다시 PC에 넣는다. 이 PC에 들어있는 값이 다음 실행할 인스트럭션의 메모리 주소이다.*  
*이제 제어기 장치는 IR에 현재 실행할 인스트럭션을 가지고 있으며, PC를 갱신했다. 그러면 현재 실행 중인 인스트럭션이 실행을 마치면, PC안에 있는 다음 인스트럭션을 다시 패치한다. 그리고 해석하고 실행할 준비를 한다.*  
INTERRUPT : 현재 F-E 중지하고 다른 F-E 주기 실행  

큰 프로그램 수행하는 법 : 주기억장치(램) 크기보다 프로그램 크기가 더 클 때는, 보조기억장치(HDD)에서 필요한 부분만 page 단위로 램에 가져와서 실행.  
그래서 램이 클수록 컴퓨터 속도가 빠른 것.  
*가상 메모리는 RAM을 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.*  
*이러한 방식은 멀티태스킹 운영 체제에서 흔히 사용되며, 실제 주기억장치보다 큰 메모리 영역을 제공하는 방법으로도 사용된다.*  

p241 그림 9.7 제어장치의 레지스터와 인스트럭션 해석기 구성 요소  
*의문 : 버스?*  

p243  
*의문 : MAR, MBR 차이점?*  

주기억장치 : RAM=Random Access Memory : R/W 가능. Random Access 접근 방식 : 메모리의 어느 위치에 있는 자료(데이터/인스트럭션 등)라도 접근하는 시간은 균등하게 일정하다.  
ROM=Read Only Memory : 내용 변경 불가. (ROM도 접근방식은 Random Access)  

p254 입출력 방법 : 프로그램에 의한 입출력 방식, 인터럽트에 의한 입출력 방식. 자세히 X. 이런 것들이 있다.  

p258 탐색시간, 지연시간, 전송시간. 하드디스크 플래터 돌 때 시간 걸린다. Random Access와 구별.  

p261 그림 9.19: 종합  

p265 새로운 개념의 컴퓨터 시스템  
병렬 컴퓨터 : 처리기가 여러 개. 여러 개의 인스트럭션을 동시에 처리.  
데이터 플로우 컴퓨터 : 데이터의 관점에서 컴퓨터의 흐름을 생각. (기존에는 인스트럭션 중심)  
광 컴퓨터 : 전류의 흐름이 아닌 빛으로 처리.  

양자 컴퓨터 : 큐비트(최소 단위)의 중첩이라는 특성을 이용. (1과 0의 두 가지 상태를 동시에 나타낼 수 있음)  

--------